#include "camera_management_task.h"
#include "usb_task.h"
#include "hm01b0_init_bytes.h"

#define __unused __attribute__((unused))

////////////////////////////////////////////////////////////////
// FreeRTOS includes
#include "FreeRTOS.h"
#include "semphr.h"
#include "task.h"
#include "queue.h"
#include "list.h"
#include "portmacro.h"

/**
 * Triggers
 *
 * The easiest way to do this is to:
 *   - by default, the camera does not record frames and instead waits for a trigger.
 *   - if the user button is short-pressed, the camera starts to generate triggers and also record
 *     frames.
 *   - Not ideal, but inter-camera triggers and mcu -> sensor triggers will all be processed by
 *     software interrupts.
 *   - Inter-camera triggers will be generated by software as well.
 */

// PF9 is the external trigger signal.
void EXTI9_5_IRQHandler() {
    if (EXTI->PR & (1 << 9)) {
        // Clear exti 9
        EXTI->PR |= (1 << 9);

        // toggle LED1
        HAL_GPIO_TogglePin(led1_GPIO_Port, led1_Pin);
    }
}

// TODO: if we are a trigger generator, then have a timer interrupt that triggers the other lilcam and
// also our image sensor


extern I2C_HandleTypeDef hi2c1;

static void init_internal_hw_trig()
{
    // setup TIM5 channel 2 on PA1 to trigger hm01b0
#if 0
    __HAL_RCC_TIM5_CLK_ENABLE();

    TIM5->
    GPIO_InitStruct.Pin = hm01b0_trig_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
    HAL_GPIO_Init(hm01b0_trig_GPIO_Port, &GPIO_InitStruct);
#endif

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = gpio3_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

    // PF9 ("gpio3") is already set up as an input; we just need to make sure it's hooked up to the
    // exti controller.
    // exti 9 source is '5' for 'F'
    SYSCFG->EXTICR[9 >> 2] &= ~(0b1111 << ((9 & 0x03) * 4));
    SYSCFG->EXTICR[9 >> 2] |=  (0b0101 << ((9 & 0x03) * 4));

    EXTI->RTSR |= (1 << 9);           // Enable rising edge on exti trigger 9
    EXTI->PR   |= (1 << 9);           // Clear exti channel 9
    EXTI->IMR  |= (1 << 9);           // Unmask exti 9

    // Enable exti[9:5] irq at a high priority
    HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
}

void camera_management_task(void const* args)
{
    init_internal_hw_trig();

    // for starters, set camera select to choose hm01b0
    HAL_GPIO_WritePin(camera_select_GPIO_Port, camera_select_Pin, GPIO_PIN_SET);

    // tim2 channel 3 is hm01b0's mclk. Drive it at 12MHz.
    // tim2 runs at 96MHz. we need to divide it by 8
    TIM2->CCER = (1 << 8);
    TIM2->CR1 |= (1 << 0);

    // let the MCLK run for a little bit before trying to do anything
    osDelay(1);

    // reset hm01b0
    {
        hm01b0_reg_write_t v = {0x0103, 0xff};
        uint8_t buf[3] = {(v.ui16Reg & 0xff00) >> 8, (v.ui16Reg & 0x00ff) >> 0, v.ui8Val};
        __unused HAL_StatusTypeDef err = HAL_I2C_Master_Transmit(&hi2c1, 0x24 << 1, buf, 3, 100);

        v.ui16Reg = 0x0103; v.ui8Val = 0x00;
        buf[0] = (v.ui16Reg & 0xff00) >> 8; buf[1] = (v.ui16Reg & 0x00ff) >> 0; buf[2] = v.ui8Val;
        err = HAL_I2C_Master_Transmit(&hi2c1, 0x24 << 1, buf, 3, 100);
    }

    // initialize hm01b0 over i2c
    for (int i = 0; i < sizeof_hm01b0_init_values / sizeof(hm01b0_init_values[0]);) {
        hm01b0_reg_write_t v = hm01b0_init_values[i++];
        uint8_t buf[3] = {(v.ui16Reg & 0xff00) >> 8, (v.ui16Reg & 0x00ff) >> 0, v.ui8Val};

        HAL_StatusTypeDef err = HAL_I2C_Master_Transmit(&hi2c1, 0x24 << 1, buf, 3, 100);

        if (err) {
            HAL_GPIO_WritePin(led2_GPIO_Port, led2_Pin, GPIO_PIN_SET);
        }

        taskYIELD();
    }

    while (1) {
        // TODO: block on requests from other threads to adjust camera settings / trigger settings
        osDelay(100);
    }
}
